request = require 'request'

config = null
couchdb = null

compile = (doc_id, newMarkup) ->
  console.log "compiling '#{doc_id}'"
  
  result = {}
  tree = []
  
  newMarkup = newMarkup.replace /\r/g, '' # delete windows chars
  error = parseBlocks tree, newMarkup
  if error
    result.error = error
    result.info = "blocks:\n\n#{JSON.stringify tree}"
    return result
  
  extractOneLiners tree
  deleteEmptyBlocks tree
  
  result.info = JSON.stringify tree
  
  return result

################################################################################
## parse

parseBlocks = (result, text) ->
  type = null
  while text and text.length > 0
    if type is null
      # no block open
      regex = /(\n\n+)|([^\\]```)|(^```)|([^\\]\$\$\$)|(^\$\$\$)|([^\\]>>>)|(^>>>)/
      index = text.search regex
      match = text.match regex
      
      if index != -1
        if match is null then return "RegExp found and not found ?!\n#{text}"
        
        match = match[0] # select first occurrence
        mayEscaped = true
        newType = null
        if match[1] is '`' then newType = \code
        else if match[1] is '$' then newType = \math
        else if match[1] is '>' then newType = \quote
        else mayEscaped = false
        
        if index != 0 # space between last closing symbol and `index`
          result.push {
            \type : \par
            \input : text.substr 0, index+mayEscaped
          }
        
        text = text.substr index+match.length # remaining text
        type = newType
      else
        result.push {
          \type : \par
          \input : text
        }
        text = null
    else
      # close blocks
      if type is \code
        index = text.search /[^\\]```/g
        if index is -1 then return 'Block not closed: CODE block'
      else if type is \math
        index = text.search /[^\\]\$\$\$/g
        if index is -1 then return 'Block not closed: MATH block'
      else if type is \quote
        index = text.search /[^\\]<<</g
        if index is -1 then return 'Block not closed: QUOTE block'
      
      # remove escape characters
      input = text.substr 0, index+1
      if type is \code then input = input.replace /\\```/g '```'
      else if type is \math then input = input.replace /\\\$\$\$/g '$$$'
      else if type is \quote then input = input.replace /\\<<</g '<<<'
      
      result.push {
        \type : type
        \input : input
      }
      
      text = text.substr index+4 # remaining text
      type = null
  
  return void

extractOneLiners = (tree) ->
  blockIndex = 0
  while blockIndex < tree.length
    block = tree[blockIndex]
    remainingText = ''
    for line of block.input.split /\n/g
      match = line.match /(^=+)|(^@)|(^\\)/
      if match # found
        match = match[0] # select first occurrence
        if match[0] is '='
          # headline
          tree.splice blockIndex, 0, {
            \type : \headline
            \depth : match.length
            \input : line.substr match.length
          }
        else if match[0] is '@'
          # definition for bibliography or link-shorthand
          tree.splice blockIndex, 0, {
            \type : \define
            \input : line
          }
        else
          # definition for bibliography or link-shorthand
          tree.splice blockIndex, 0, {
            \type : \command
            \input : line.substr 1
          }
        
        blockIndex ++
      else
        remainingText += line+'\n'
    
    block.input = remainingText
    blockIndex ++
  return void

deleteEmptyBlocks = (tree) ->
  for index from tree.length-1 to 0 by -1
    if not tree[index].input or tree[index].input.length is 0
      tree.splice index, 1
  return void

################################################################################
# create html

################################################################################
# other

_delChars = (text, startIndex, length) ->
  firstPart = text.substr 0, startIndex
  lastPart = text.substr startIndex+length
  return firstPart+lastPart

module.exports = compile

compile.setConfiguration = (configuration) ->
  config := configuration
  couchdb := "http://#{config.couchdb.host}:#{config.couchdb.port}/#{config.couchdb.dbname}/"

