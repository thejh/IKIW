request = require 'request'

config = null
couchdb = null

compile = (doc_id, newMarkup, onFinish) ->
  console.log "compiling '#{doc_id}'"
  
  result = {}
  tree = []
  
  # TODO catch errors / exceptions
  
  newMarkup = newMarkup.replace /\r/g, '' # delete windows chars
  error = parseBlocks tree, newMarkup
  if error
    result.error = "ERROR while parsing blocks:\n#{error}"
    result.info = "blocks parsed yet:\n\n#{JSON.stringify tree}"
    
    onFinish result
    return result
  
  extractOneLiners tree # extract commands, headlines and defines
  deleteEmptyBlocks tree # delete blocks that contained only one-liners
  
  error = parseLists tree # identify and parse lists
  if error
    result.error = "ERROR while parsing lists:\n#{error}"
    result.info = "tree so far:\n\n#{JSON.stringify tree}"
    
    onFinish result
    return result
  
  error parseParagraphs tree
  if error
    result.error = "ERROR while parsing paragraphs:\n#{error}"
    result.info = "tree so far:\n\n#{JSON.stringify tree}"
    
    onFinish result
    return result
  
  result.info = JSON.stringify tree
  
  onFinish result

################################################################################
## parse

parseBlocks = (result, text) ->
  type = null
  while text and text.length > 0
    if type is null
      # no block open
      regex = /(\n\n+)|([^\\]```)|(^```)|([^\\]\$\$\$)|(^\$\$\$)|([^\\]>>>)|(^>>>)/
      index = text.search regex
      match = text.match regex
      
      if index != -1
        if match is null then return "RegExp found and not found ?!\n#{text}"
        
        match = match[0] # select first occurrence
        mayEscaped = true
        newType = null
        if match[1] is '`' then newType = \code
        else if match[1] is '$' then newType = \math
        else if match[1] is '>' then newType = \quote
        else mayEscaped = false
        
        if index != 0 # space between last closing symbol and `index`
          result.push {
            \type : \par
            \input : text.substr 0, index+mayEscaped
          }
        
        text = text.substr index+match.length # remaining text
        type = newType
      else
        result.push {
          \type : \par
          \input : text
        }
        text = null
    else
      # close blocks
      if type is \code
        index = text.search /[^\\]```/g
        if index is -1 then return 'Block not closed: CODE block'
      else if type is \math
        index = text.search /[^\\]\$\$\$/g
        if index is -1 then return 'Block not closed: MATH block'
      else if type is \quote
        index = text.search /[^\\]<<</g
        if index is -1 then return 'Block not closed: QUOTE block'
      
      # remove escape characters
      input = text.substr 0, index+1
      if type is \code then input = input.replace /\\```/g '```'
      else if type is \math then input = input.replace /\\\$\$\$/g '$$$'
      else if type is \quote then input = input.replace /\\<<</g '<<<'
      
      result.push {
        \type : type
        \input : input
      }
      
      text = text.substr index+4 # remaining text
      type = null
  
  return void

extractOneLiners = (tree) ->
  blockIndex = 0
  while blockIndex < tree.length
    block = tree[blockIndex]
    remainingText = ''
    for line of block.input.split /\n/g
      match = line.match /(^=+)|(^@)|(^\\)/
      if match # found
        match = match[0] # select first occurrence
        if match[0] is '='
          # headline
          tree.splice blockIndex, 0, {
            \type : \headline
            \depth : match.length
            \input : line.substr match.length
          }
        else if match[0] is '@'
          # definition for bibliography or link-shorthand
          tree.splice blockIndex, 0, {
            \type : \define
            \input : line
          }
        else
          # definition for bibliography or link-shorthand
          tree.splice blockIndex, 0, {
            \type : \command
            \input : line.substr 1
          }
        
        blockIndex ++
      else
        remainingText += line+'\n'
    
    block.input = remainingText
    blockIndex ++
  
  return void

deleteEmptyBlocks = (tree) ->
  for index from tree.length-1 to 0 by -1
    if not tree[index].input or tree[index].input.length is 0
      tree.splice index, 1
  return void

parseLists = (tree) ->
  for block, blockIndex of tree
    if block.type !== \par then continue
    
    match = block.input.match /^\s*-[^-]/
    if match
      block.type = \unorderedlist
      error = _parseList block, block.input, blockIndex
      if error then return error
    else
      match = block.input.match /(^\s*#[^#])/
      if match
        block.type = \orderedlist
        error = _parseList block, block.input, blockIndex
        if error then return error
  
  return void

_parseList = (block, input, blockIndex) ->
  stack = [block]
  block.items = []
  
  lines = input.split /\n/g
  if lines.length == 0
    return void
  
  item = \text : "#{lines[0].substr(lines[0].match(/(^\s*-)|(^\s*#)/)[0].length)}\n" # del list symbols
  _peek stack .items.push item
  stack.push item
  lines.splice 0, 1 # delete first line in `lines`
  
  for line, lineIndex of lines
    match = line.match /^\s*-+/
    if match
      type = \unorderedlist
      depth = line.match(/-+/)[0].length
    else
      match = line.match /^\s*#+/
      if match
        type = \orderedlist
        depth = line.match(/#+/)[0].length
      else # no \- or \# in the beginning
        _peek stack .text += line+'\n'
        continue
    
    line = line.substr(line.match(/(^\s*-+)|(^\s*#+)/)[0].length)+'\n' # del list symbols
    
    if depth is stack.length-1 # same depth as previous item
      if type is stack[stack.length-2].type
        # new item, same list
        
        stack.pop!
        item = \text : line
        _peek stack .items.push item
        stack.push item
      else
        return "List type not compatible in block #{blockIndex+1} line #{lineIndex+2}."
    else if depth is stack.length
      # higher depth than previous item, open new sublist
      
      peek = _peek stack
      
      if not peek.type then peek.type = type
      if not peek.items then peek.items = []
      
      item = \text : line
      peek.items.push item
      stack.push item
    else if depth > stack.length
      return "Depth to high in block #{blockIndex+1} line #{lineIndex+2}."
    else
      # close other lists
      stack.pop! while stack.length > depth
      
      peek = _peek stack
      
      if peek.type !== type
        return "List type not compatible in block #{blockIndex+1} line #{lineIndex+2}."
      
      item = \text : line
      peek.items.push item
      stack.push item
  
  return void

parseParagraphs = (tree) ->
  for block, blockIndex of tree
    if block.type is \par
      parseBlock block, blockIndex

_parseParagraph = (block, blockIndex) ->
  stack = [block] # opened elements
  block.elements = [{\text : ''}]
  
  remainder = block.input
  while remainder.length > 0
    regex = /(^`)|([^\\]`)/g
    index = remainder.search regex
    if index !== -1
      match = remainder.match regex
      if index > 0
        if match.length is 1 then _peek stack .text += remainder.substr 0, index
        else _peek stack .text += remainder.substr 0, index+1 # escapable
      
      __closeAllElements stack
      elem = {
        \text : ''
        \type : code
      }
        

# closes all elements on the stack, except the first (the whole block)
# elements that can be closed by this method: *, _, ยง
__closeAllElements = (stack) ->
  while block.length > 1
    peek = _peek stack
    if peek.type is `` then
    #TODO

# extracts the parameters in the beginning of the text. text= `[paremeter] ...`
# returns: {\parameter: object (JSON), \text: (remaining text)}
__getParam = (text) ->
  if text.search /^\[/ !== 0
    # no parameters given
    return {\parameter : {}, \text : text}
  
  text = text.substr 1, text.length
  index = text.search /(^\])|([^\\]\])/
  if index is 0
    # parameter empty or malformed
    return {\parameter : {}, \text : text.substr match.length, text.length}
  
  param = text.substr 0, index+1
  remaining = text.substr index+2
  
  parsed = JSON.parse param
  
  return {
    \parameter : parsed
    \text : remaining
  }

################################################################################
# create html

################################################################################
# other

_delChars = (text, startIndex, length) ->
  firstPart = text.substr 0, startIndex
  lastPart = text.substr startIndex+length
  firstPart+lastPart

_peek = (elementStack) ->
  elementStack[elementStack.length-1]

module.exports = compile

compile.setConfiguration = (configuration) ->
  config := configuration
  couchdb := "http://#{config.couchdb.host}:#{config.couchdb.port}/#{config.couchdb.dbname}/"

